| Лабораторная работа №4    | M3137                    | Архитектура ЭВМ |
| ------------------------- |--------------------------| ---- |
| Кэш и кодирование команд  | Кудашова Ольга Андреевна | 2024 |


# Расчёт параметров системы

Полученные параметры системы:

| Параметр         | Значение (с единицами измерения) |
| ---------------- |----------------------------------|
| MEM_SIZE         | 256 Кбайт                        |
| ADDR_LEN         | 18 бит                           |
| CACHE_WAY        | 4                                |
| CACHE_TAG_LEN    | 9 бит                            |
| CACHE_INDEX_LEN  | 3 бита                           |
| CACHE_OFFSET_LEN | 6 бит                            |
| CACHE_SIZE       | 2 Кбайта                         |
| CACHE_LINE_SIZE  | 64 байт                          |
| CACHE_LINE_COUNT | 32                               |
| CACHE_SETS       | 8                                |

Расчёт:

1. Параметры ```ADDR_LEN```, ```CACHE_INDEX_LEN```, ```CACHE_LINE_SIZE```, ```CACHE_LINE_COUNT``` - из условия.
2. Размер памяти вычисляется как ```MEM_SIZE``` = 2<sup>```ADDR_LEN```</sup>
3. ```CACHE_SETS``` = 2<sup>```CACHE_INDEX_LEN```</sup> (именно столько может быть разных индексов, от 0 до 2<sup>```CACHE_INDEX_LEN```</sup>-1)
4. Аналогично ```CACHE_OFFSET_LEN``` = log<sub>2</sub>(```CACHE_LINE_SIZE```)
5. Оставшиеся биты адреса занимает тэг: ```CACHE_TAG_LEN``` = ```ADDR_LEN``` - ```CACHE_INDEX_LEN``` - ```CACHE_OFFSET_LEN``` 
6. ```CACHE_SIZE``` = ```CACHE_LINE_SIZE```*```CACHE_LINE_COUNT``` (общий размер кэша)
7. ```CACHE_WAY``` = ```CACHE_LINE_COUNT```/```CACHE_SETS``` (ассоциативность = количество блоков)


# Структура кэш-линии

```java
private static class CacheLine {
    boolean valid = false;
    boolean dirty = false;
    int tag;
    int[] data = new int[CACHE_LINE_SIZE];
    boolean mru = false;
}
```

#### Поле valid
+ Тип: ```boolean```
+ Указывает, является ли кэш-линия валидной. 
Если `valid` равно `false`, это означает, что содержимое кэш-линии не актуально, и данные не могут быть использованы.
+ При создании проинициализирована `false`, так как кэш изначально пуст.

#### Поле dirty
+ Тип: ```boolean```
+ Указывает, были ли данные в кэш-линии изменены.
Если `dirty` равно `true`, это говорит о том, данные были перезаписаны, и при вытеснении кэш-линии её надо будет записать обратно в память (метод `writeBackToMemory`). 
Если `false`, то при вытеснении данные можно просто удалить, так как они остаются актуальными в основной памяти.
+ При создании проинициализирована `false`, так как кэш изначально пуст.

#### Поле tag
+ Тип: ```int```
+ Тег используется для идентификации кэш-линии. Он соответствует адресу блока данных в основной памяти и используется для проверки, соответствует ли проверяемый адрес этому блоку.
+ При обращении к кэшу тег адреса сравнивается с тегом кэш-линии для определения попадания.
+ При обновлении кэш-линии её тег меняется на тег адреса.

#### Поле data
+ Тип: ```int[]```
+ Представляет собой массив размера `CACHE_LINE_SIZE`.
+ Запись данных происходит в ячейку `data[offset]`. При `writeBackToMemory` в память записывется каждая ячейка кэш-линии.

#### Поле mru
+ (!) Есть только в классе BitPLruCache, в классе LruCache не используется.
+ Тип: ```boolean```
+ Специальный бит, который инициализируется 1 (т. е. `true`), если линия недавно была использована, и 0, если нет.
+ При cache miss выбираем линию с mru = false.
+ Когда у всех кэш-линий mru = 1, сбрасываем. (Метод `resetBits`)
+ При создании проинициализирована `false`, так как кэш-линии ещё не были использованы.


# Решение задачи rv32task.asm

По условию необходимо было написать программу на асемблере, при исполнении которой можно было добиться следующих процентов:

hit(instr): 91.66667%

hit(data): 75.00000%
```
То есть для инструкций нам надо добиться cache hit в 11 из 12 случаев, а для данных в 3 из 4.
```

### Данные

Всего в моей программе происходит 4 обращения к памяти:
1. sw a7, 2, s0
2. sh t0, 17, s8
3. lb s0, 2, s3  (2 раза внутри цикла blt-jal)

Data miss происходит только при первом обращении, так как при следующих индексы и теги адресов совпадают, и они попадают в одну кэш-линию.


### Инструкции

В начале цикла значение регистра s2 равно 512, регистра s3 - 26. 
```assembly
blt s2, s3, 80
addi s2, s2, -250
lb s0, 2, s3
lui s10, 2
addi s3, s3, 12
jal zero, -20
```
+ Цикл выполняется пока s2 >= s3. 
+ После первой итерации значения регистров равны 262 и 38. 
Команда jal возвращает PC на команду blt, и операции выполняются вновь. 
+ В конце второй итерации значение s2 становится меньше, чем значение s3 (12 и 50), и команда blt увеличивает PC на 80, в результате чего мы выходим из цикла, и программа завершается.

> Таким образом, команды, предшествующие blt, выполняются по 1 разу, а команды в цикле - 2 раза. Команда blt исполняется 3 раза.

Итого, суммарно исполняется 24 команды. 

Кэш-промахи происходят на первой команде(что логично, так как ещё ни в одну кэш-линию не были загружены данные), и также на команде jalr, так как в одной кэш-линии помещаются только 16 команд.
Всего 22 попадания из 24, что соответствует проценту 91.66667%.

В коде присутствуют требуемые в задани инструкции fence, lui, addi, а также многие другие:
```assembly
addi s0, zero, 16
...
fence rw, r
...
lui s10, 2
...
```
